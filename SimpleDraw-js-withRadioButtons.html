<html>
<body>

<script language="JavaScript">
var MODE_DRAW = 1;
var MODE_SELECT = 2;
var MODE_MOVE = 3;
var MODE_ERASE = 4;
var mode = MODE_DRAW;  // Mode initial: dessin
var previousMode = MODE_DRAW;

var selectedColor = "#000000"; 
var eraseRadius = 30; 
var copyOffset = 30;  // Décalage des copies

</script>

<canvas id="myCanvas" width="500" height="600" style="border:2px solid #000000;"> </canvas>
<br/>
<label><input type='radio' id="radio_draw" name="radio_mode" onclick='setMode(MODE_DRAW);' checked>Draw</label>
<label><input type='radio' id="radio_select" name="radio_mode" onclick='setMode(MODE_SELECT);'>Rectangle Select</label>
<label><input type='radio' id="radio_move" name="radio_mode" onclick='setMode(MODE_MOVE);'>Move Selection</label>
<label><input type='radio' id="radio_erase" name="radio_mode" onclick='setMode(MODE_ERASE);'>Erase</label>

<div style="display: flex; gap: 10px; margin-top: 5px;"></div>
<button onclick="deleteSelection()">Supprimer la selection</button>
<button onclick="copySelection()">Copier la selection</button>
</div>

<button onclick="clearButtonHandler()">Delete All</button>

<!-- Titre pour la palette de couleurs -->
<h3>Palette de couleurs</h3>

<div style="display: flex; gap: 5px; margin-top: 5px;">
    <button id="btnNoir" onclick="setColor('#000000')" style="background-color: #000000; width: 30px; height: 30px; border: 3px solid yellow;"></button>
    <button id="btnRouge" onclick="setColor('#FF0000')" style="background-color: #FF0000; width: 30px; height: 30px; border: 3px solid black;"></button>
    <button id="btnVert" onclick="setColor('#00FF00')" style="background-color: #00FF00; width: 30px; height: 30px; border: 3px solid black;"></button>
    <button id="btnBleu" onclick="setColor('#0000FF')" style="background-color: #0000FF; width: 30px; height: 30px; border: 3px solid black;"></button>
</div>

<script language="JavaScript">

var canvas = document.getElementById("myCanvas");
var canvas_context = canvas.getContext("2d");

var mouse_previous_x = 0;
var mouse_previous_y = 0;
var buttonIsDown = false;

var arrayOfStrokes = [];
var selectedStrokes = [];
var stroke = [];
var selectionRectangle = null;
var isMoving = false;

function setMode(newMode) {
    previousMode = mode;  
    mode = newMode;
    document.getElementById('radio_draw').checked = (mode === MODE_DRAW);
    document.getElementById('radio_select').checked = (mode === MODE_SELECT);
    document.getElementById('radio_move').checked = (mode === MODE_MOVE);
    document.getElementById('radio_erase').checked = (mode === MODE_ERASE);

    if (mode === MODE_DRAW && previousMode !== MODE_DRAW) {
        selectedStrokes = [];
    }

    redraw();
}

function mouseDownHandler(e) {
    buttonIsDown = true;
    var canvas_rectangle = canvas.getBoundingClientRect();
    var event_x = e.clientX - canvas_rectangle.left;
    var event_y = e.clientY - canvas.getBoundingClientRect().top;

    stroke = [];
    switch (mode) {
        case MODE_DRAW:
            stroke.push({ x: event_x, y: event_y, color: selectedColor });
            selectedStrokes = []; 
            break;
        case MODE_SELECT:
            selectionRectangle = { x1: event_x, y1: event_y, x2: event_x, y2: event_y };
            break;
        case MODE_MOVE:
            if (selectedStrokes.length > 0) {
                isMoving = true;  
            }
            break;
        case MODE_ERASE:
            eraseStrokes(event_x, event_y); 
            break;
    }
    mouse_previous_x = event_x;
    mouse_previous_y = event_y;
}

function mouseUpHandler(e) {
    buttonIsDown = false;
    var canvas_rectangle = canvas.getBoundingClientRect();
    var event_x = e.clientX - canvas_rectangle.left;
    var event_y = e.clientY - canvas.getBoundingClientRect().top;

    switch (mode) {
        case MODE_DRAW:
            if (stroke.length > 2) {
                arrayOfStrokes.push(stroke);
            }
            stroke = [];
            break;
        case MODE_SELECT:
            selectStrokesInRectangle(selectionRectangle);
            selectionRectangle = null;
            break;
        case MODE_MOVE:
            isMoving = false;
            break;
    }
    mouse_previous_x = event_x;
    mouse_previous_y = event_y;
}

function mouseMoveHandler(e) {
    var canvas_rectangle = canvas.getBoundingClientRect();
    var event_x = e.clientX - canvas_rectangle.left;
    var event_y = e.clientY - canvas.getBoundingClientRect().top;

    switch (mode) {
        case MODE_DRAW:
            if (buttonIsDown) {
                stroke.push({ x: event_x, y: event_y, color: selectedColor });
            }
            break;
        case MODE_SELECT:
            if (buttonIsDown) {
                selectionRectangle.x2 = event_x;
                selectionRectangle.y2 = event_y;
            }
            break;
        case MODE_MOVE:
            if (buttonIsDown && isMoving) {
                var offsetX = event_x - mouse_previous_x;
                var offsetY = event_y - mouse_previous_y;
                moveSelectedStrokes(offsetX, offsetY);
            }
            break;
        case MODE_ERASE:
            if (buttonIsDown) {
                eraseStrokes(event_x, event_y);
            }
            break;
    }

    redraw();
    mouse_previous_x = event_x;
    mouse_previous_y = event_y;
}

canvas.addEventListener('mousedown', mouseDownHandler);
canvas.addEventListener('mouseup', mouseUpHandler);
canvas.addEventListener('mousemove', mouseMoveHandler);

function drawStroke(s, isSelected = false) {
    if (isSelected) {
        canvas_context.beginPath();
        canvas_context.strokeStyle = "orange"; 
        canvas_context.lineWidth = 8; 
        for (var i = 0; i < s.length; ++i) {
            var x = s[i].x;
            var y = s[i].y;
            if (i === 0) {
                canvas_context.moveTo(x, y);
            } else {
                canvas_context.lineTo(x, y);
            }
        }
        canvas_context.stroke();
    }

    canvas_context.beginPath();
    canvas_context.strokeStyle = s[0].color || "#000000";
    canvas_context.lineWidth = 2; 
    for (var i = 0; i < s.length; ++i) {
        var x = s[i].x;
        var y = s[i].y;
        if (i === 0) {
            canvas_context.moveTo(x, y);
        } else {
            canvas_context.lineTo(x, y);
        }
    }
    canvas_context.stroke();
}

var redraw = function() {
    canvas_context.clearRect(0, 0, canvas.width, canvas.height);

    for (var i = 0; i < arrayOfStrokes.length; ++i) {
        var isSelected = selectedStrokes.indexOf(arrayOfStrokes[i]) !== -1;
        drawStroke(arrayOfStrokes[i], isSelected);
    }

    if (buttonIsDown && mode === MODE_DRAW) {
        canvas_context.strokeStyle = selectedColor;
        drawStroke(stroke);
    }

    if (selectionRectangle !== null) {
        canvas_context.strokeStyle = "#FF0000";
        canvas_context.strokeRect(
            selectionRectangle.x1, selectionRectangle.y1,
            selectionRectangle.x2 - selectionRectangle.x1, selectionRectangle.y2 - selectionRectangle.y1
        );
    }

    // Ajouter le cercle d'effacement en mode "Erase"
    if (mode === MODE_ERASE) {
        canvas_context.beginPath();
        canvas_context.arc(mouse_previous_x, mouse_previous_y, eraseRadius, 0, 2 * Math.PI);
        canvas_context.strokeStyle = "#FF0000";  // Couleur du cercle d'effacement
        canvas_context.lineWidth = 2;
        canvas_context.stroke();
    }
}

function clearButtonHandler() {
    arrayOfStrokes = [];
    selectedStrokes = [];
    redraw();
}

function setColor(color) {
    selectedColor = color;
    updateSelectedColorBorder();
}

function updateSelectedColorBorder() {
    var buttons = ["btnNoir", "btnRouge", "btnVert", "btnBleu"];
    buttons.forEach(function(buttonId) {
        var button = document.getElementById(buttonId);
        var buttonColor = window.getComputedStyle(button).backgroundColor;
        var selectedRGBColor = hexToRGB(selectedColor);
        button.style.border = (buttonColor === selectedRGBColor) ? "3px solid yellow" : "3px solid black";
    });
}

function hexToRGB(hex) {
    var r = parseInt(hex.slice(1, 3), 16);
    var g = parseInt(hex.slice(3, 5), 16);
    var b = parseInt(hex.slice(5, 7), 16);
    return `rgb(${r}, ${g}, ${b})`;
}

updateSelectedColorBorder();

// Fonction pour déplacer les traits sélectionnés
function moveSelectedStrokes(offsetX, offsetY) {
    for (var i = 0; i < selectedStrokes.length; i++) {
        for (var j = 0; j < selectedStrokes[i].length; j++) {
            selectedStrokes[i][j].x += offsetX;
            selectedStrokes[i][j].y += offsetY;
        }
    }
    redraw();
}

// Fonction pour effacer les traits en contact avec le cercle d'effacement
function eraseStrokes(x, y) {
    for (var i = arrayOfStrokes.length - 1; i >= 0; i--) {
        var stroke = arrayOfStrokes[i];
        for (var j = 0; j < stroke.length; j++) {
            var point = stroke[j];
            var distance = Math.sqrt((point.x - x) ** 2 + (point.y - y) ** 2);
            if (distance < eraseRadius) {
                arrayOfStrokes.splice(i, 1);  
                break;
            }
        }
    }
    redraw();
}

// Fonction pour sélectionner les traits dans le rectangle
function selectStrokesInRectangle(rect) {
    selectedStrokes = [];
    for (var i = 0; i < arrayOfStrokes.length; i++) {
        var stroke = arrayOfStrokes[i];
        if (isStrokeInRectangle(stroke, rect)) {
            selectedStrokes.push(stroke);
        }
    }
    redraw();
}

// Fonction pour supprimer la sélection
function deleteSelection() {
    if (selectedStrokes.length === 0) {
        console.log("Aucune sélection à supprimer.");
        return;
    }
    arrayOfStrokes = arrayOfStrokes.filter(function(stroke) {
        return selectedStrokes.indexOf(stroke) === -1;
    });
    selectedStrokes = [];
    redraw();
}

// Fonction pour copier la sélection
function copySelection() {
    if (selectedStrokes.length === 0) {
        console.log("Aucune sélection à copier.");
        return;
    }

    var newStrokes = selectedStrokes.map(function(stroke) {
        var newStroke = stroke.map(function(point) {
            return { x: point.x + copyOffset, y: point.y + copyOffset, color: point.color };
        });
        return newStroke;
    });

    arrayOfStrokes = arrayOfStrokes.concat(newStrokes);
    selectedStrokes = newStrokes; 
    redraw();
}

function isStrokeInRectangle(stroke, rect) {
    var xMin = Math.min(rect.x1, rect.x2);
    var xMax = Math.max(rect.x1, rect.x2);
    var yMin = Math.min(rect.y1, rect.y2);
    var yMax = Math.max(rect.y1, rect.y2);

    for (var i = 0; i < stroke.length; i++) {
        var point = stroke[i];
        if (point.x < xMin || point.x > xMax || point.y < yMin || point.y > yMax) {
            return false;
        }
    }
    return true;
}

</script>

</body>
</html>
